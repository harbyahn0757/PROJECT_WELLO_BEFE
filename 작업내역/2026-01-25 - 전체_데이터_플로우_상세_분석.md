# 전체 데이터 플로우 상세 분석
**작성일**: 2026-01-25  
**목적**: 프론트엔드 → 백엔드 → 프론트엔드 스트리밍 및 중간 저장 전체 추적

---

## 1. 전체 플로우 개요

```
[랜딩 페이지]
  ↓ 약관 동의
[AuthForm - 세션 시작]
  ↓
[백엔드 - 세션 생성]
  ↓
[백엔드 - Tilko 인증]
  ↓
[백엔드 - 데이터 수집]
  ↓
[WebSocket 스트리밍]
  ↓
[프론트엔드 - 데이터 수신 및 저장]
  ↓
[화면 전환]
```

---

## 2. 단계별 상세 플로우

### Phase 1: 세션 시작 (프론트엔드 → 백엔드)

#### 2.1 프론트엔드 요청
**파일**: `useAuthFlow.ts:437-506`

**요청 데이터**:
```typescript
{
  user_name: string,
  phone_no: string,
  birthdate: string,
  private_auth_type: string,
  gender: 'M',
  oid?: string,
  redirect_path?: string,        // ✅ 새로 추가
  terms_agreed?: boolean,        // ✅ 새로 추가
  terms_agreed_at?: string,      // ✅ 새로 추가
  terms_expires_at?: string      // ✅ 새로 추가
}
```

**localStorage 저장**:
- `STORAGE_KEYS.TILKO_SESSION_ID` (세션 ID 저장 - 응답 후)

**요청 위치**: `POST /api/v1/tilko/session/start`

---

#### 2.2 백엔드 세션 생성
**파일**: `tilko_auth.py:156-250`

**처리 순서**:
1. 사용자 정보 정규화 (이름 suffix 제거)
2. Redis 세션 생성 (`session_manager.create_session()`)
3. 세션 데이터에 커스텀 필드 추가:
   - `redirect_path` (진입 경로)
   - `terms_agreed`, `terms_agreed_at`, `terms_expires_at` (약관 정보)
   - `patient_uuid`, `hospital_id` (기존 환자인 경우)
   - `oid` (캠페인 주문번호)

**Redis 저장 위치**: `tilko_session:{session_id}`
**TTL**: 30분 (1800초)

**응답**:
```json
{
  "success": true,
  "session_id": "uuid",
  "message": "...",
  "next_step": "simple_auth"
}
```

---

### Phase 2: Tilko 인증 (프론트엔드 → 백엔드 → Tilko API)

#### 2.1 프론트엔드 인증 요청
**파일**: `useAuthFlow.ts:529-534`

**요청**: `POST /api/v1/tilko/session/simple-auth?session_id={sessionId}`

---

#### 2.2 백엔드 Tilko API 호출
**파일**: `tilko_auth.py:264-520`

**처리**:
1. Tilko 간편인증 API 호출
2. `temp_auth_data` 세션에 저장 (인증 완료 전)
3. WebSocket 알림: `auth_key_received` (cxId 포함)

**Redis 업데이트**:
- `session_data["temp_auth_data"]` = {cxId, token, ...}
- `session_data["status"]` = "auth_pending"

---

#### 2.3 인증 완료 감지
**방법 1**: 백엔드 스트리밍 모니터 (`streaming_auth_monitor`)
- 2초마다 `check_auth_status()` 호출
- 최대 5회 (10초 제한)

**방법 2**: 프론트엔드 폴링
- `AuthForm.tsx:732-888` - 2초마다 세션 상태 확인

**인증 완료 시**:
- `temp_auth_data` → `auth_data` 변환
- `session_data["status"]` = "auth_completed"
- WebSocket 알림: `auth_completed`

---

### Phase 3: 데이터 수집 시작

#### 3.1 프론트엔드 데이터 수집 요청
**파일**: `AuthForm.tsx` (수동 버튼 클릭 또는 자동)

**요청**: `POST /api/v1/tilko/session/{sessionId}/collect-data`

---

#### 3.2 백엔드 데이터 수집 시작
**파일**: `tilko_auth.py:1154-1207`

**처리**:
1. 중복 수집 방지 체크
2. `temp_auth_data` → `auth_data` 변환
3. 백그라운드 태스크 시작: `collect_health_data_background_task()`

**Redis 업데이트**:
- `session_data["collection_started"]` = True
- `session_data["status"]` = "fetching_health_data"

---

### Phase 4: 건강검진 데이터 수집

#### 4.1 Tilko API 호출
**파일**: `tilko_auth.py:1292-1511`

**처리**:
1. `get_health_screening_data(auth_data)` 호출
2. 응답 데이터 세션에 저장: `session_manager.update_health_data()`

**Redis 저장**:
- `session_data["health_data"]` = {Status, ResultList, ...}

**WebSocket 알림**:
- `notify_streaming_status("fetching_health_data", ...)`
- `notify_streaming_status("health_data_completed", ...)` ← **중요!**

**알림 데이터**:
```python
{
    "count": health_count,
    "patient_uuid": patient_uuid,      # ✅ 새로 추가
    "hospital_id": hospital_id          # ✅ 새로 추가
}
```

---

#### 4.2 프론트엔드 수신 및 저장
**파일**: `AuthForm.tsx:514-570`

**WebSocket 이벤트**: `health_data_completed`

**처리**:
1. UUID/Hospital ID 추출 및 localStorage 저장:
   - `STORAGE_KEYS.PATIENT_UUID`
   - `STORAGE_KEYS.HOSPITAL_ID`

2. 진입 경로 확인:
   - URL 파라미터 `redirect` 확인
   - 질병예측리포트: 스피너 유지 + 토스트
   - 추이보기: 즉시 화면 전환 + 토스트

3. **IndexedDB 저장은 아직 안함!** (완료 후에만)

---

#### 4.3 백엔드 진입 경로별 분기
**파일**: `tilko_auth.py:1513-1534`

**처리**:
- 세션에서 `redirect_path` 확인
- 질병예측리포트 (`'disease-report' in redirect_path`):
  - Mediarc 생성 시작: `_generate_mediarc_with_notification()`
- 추이보기:
  - 추가 처리 없음 (기존 로직)

---

### Phase 5: 환자 식별 및 약관 저장

#### 5.1 환자 식별
**파일**: `tilko_auth.py:1722-2026`

**순서**:
1. 캠페인 UUID 확인 (oid가 있는 경우)
2. 기존 환자 조회 (전화번호 + 생년월일 + 이름)
3. 없으면 새 환자 생성 (UUID 생성)

**PostgreSQL 저장**:
- `welno.welno_patients` 테이블
- `welno_service.save_patient_data()`

**Redis 업데이트**:
- `session_data["patient_uuid"]` = patient_uuid
- `session_data["hospital_id"]` = hospital_id

---

#### 5.2 약관 DB 저장
**파일**: `tilko_auth.py:1891-1925, 1986-2020`

**조건**: `session_data.get("terms_agreed") == True`

**PostgreSQL 저장**:
- `welno.tb_wello_terms_agreement` 테이블
- `INSERT ... ON CONFLICT DO UPDATE`

**저장 데이터**:
- `patient_uuid`, `hospital_id`
- `agreed` = True
- `agreed_at`, `expires_at` (세션에서 가져옴)

---

### Phase 6: 데이터 파일 저장

#### 6.1 파일 우선 저장
**파일**: `tilko_auth.py:2028-2050`

**저장 위치**: `/home/workspace/PROJECT_WELLO_BEFE/tilko_data/pending/`

**저장 파일들**:
1. `{timestamp}_{session_id}_patient_data.json`
2. `{timestamp}_{session_id}_health_data.json`
3. `{timestamp}_{session_id}_prescription_data.json`

**파일 구조**:
```json
{
  "metadata": {
    "session_id": "...",
    "data_type": "health_data",
    "patient_uuid": "...",
    "hospital_id": "...",
    "created_at": "...",
    "status": "pending"
  },
  "raw_data": {...},
  "checksum": "..."
}
```

---

#### 6.2 파일 → DB 저장
**파일**: `tilko_auth.py:2052-2059`

**처리**:
- `file_first_service.process_pending_files_to_db(max_files=10)`
- pending 폴더의 파일들을 순차적으로 DB에 저장
- 성공 시: `completed` 폴더로 이동
- 실패 시: `failed` 폴더로 이동

**PostgreSQL 저장**:
- `welno.welno_checkup_data` (건강검진)
- `welno.welno_prescription_data` (처방전)

---

### Phase 7: 처방전 데이터 수집

#### 7.1 Tilko API 호출
**파일**: `tilko_auth.py:1580-1710`

**처리**:
1. `get_prescription_data(auth_data)` 호출
2. 응답 데이터 세션에 저장: `session_manager.update_prescription_data()`

**Redis 저장**:
- `session_data["prescription_data"]` = {Status, ResultList, ...}

**WebSocket 알림**:
- `notify_streaming_status("prescription_completed", ...)` ← **새로 추가!**

**알림 데이터**:
```python
{
    "count": prescription_count,
    "patient_uuid": patient_uuid,
    "hospital_id": hospital_id
}
```

---

#### 7.2 프론트엔드 수신 및 토스트
**파일**: `AuthForm.tsx:634-645`

**WebSocket 이벤트**: `prescription_completed`

**처리**:
- 토스트 알림만 표시
- IndexedDB 저장은 완료 시점에만

---

### Phase 8: 데이터 수집 완료

#### 8.1 백엔드 완료 처리
**파일**: `tilko_auth.py:1713-1775`

**처리**:
1. 최종 데이터 확인 (health_data, prescription_data)
2. 세션 완료 플래그 설정:
   - `collection_started` = False
   - `collection_completed` = True
   - `collection_end_time` = now()

3. 파일 저장 (이미 완료됨)
4. DB 저장 (이미 완료됨)

**WebSocket 알림**:
- `notify_streaming_status("completed", ...)`

---

#### 8.2 프론트엔드 완료 처리
**파일**: `AuthForm.tsx:553-607, 700-832`

**WebSocket 이벤트**: `completed` 또는 `onStatusUpdate(status='completed')`

**처리**:
1. IndexedDB 저장:
   - `WelnoIndexedDB.saveHealthData(healthRecord, 'merge')`
   - 저장 모드: `'merge'` (기존 데이터와 병합)

2. localStorage 저장:
   - `STORAGE_KEYS.PATIENT_UUID`
   - `STORAGE_KEYS.HOSPITAL_ID`

3. 비밀번호 모달 표시:
   - `setPasswordSetupData({ uuid, hospital, type: 'setup' })`
   - `setShowPasswordSetupModal(true)`

**IndexedDB 저장 데이터 구조**:
```typescript
{
  uuid: string,
  patientName: string,
  hospitalId: string,
  birthday: string,
  healthData: Array,      // ResultList
  prescriptionData: Array, // ResultList
  createdAt: string,
  updatedAt: string,
  dataSource: 'tilko'
}
```

---

### Phase 9: Mediarc 리포트 생성 (질병예측리포트 케이스만)

#### 9.1 Mediarc 생성 시작
**파일**: `tilko_auth.py:2591-2606`

**WebSocket 알림**:
- `notify_streaming_status("mediarc_generating", ...)`

**프론트엔드 수신**:
- `AuthForm.tsx:573-585`
- 토스트: "리포트 생성 중"
- 스피너 유지

---

#### 9.2 Mediarc 생성 완료
**파일**: `tilko_auth.py:2608-2628`

**처리**:
1. `generate_mediarc_report_async()` 호출
2. PostgreSQL 저장:
   - `welno.welno_mediarc_reports`
   - `welno.tb_campaign_payments` (oid가 있는 경우)
   - `welno.welno_patients.has_mediarc_report` = True

**WebSocket 알림**:
- `notify_streaming_status("mediarc_completed_password_ready", ...)`

**알림 데이터**:
```python
{
    "patient_uuid": patient_uuid,
    "hospital_id": hospital_id
}
```

---

#### 9.3 프론트엔드 수신 및 비밀번호 모달
**파일**: `AuthForm.tsx:588-610`

**WebSocket 이벤트**: `mediarc_completed_password_ready`

**처리**:
1. 토스트: "리포트 생성 완료! 비밀번호를 설정해주세요."
2. 스피너 중지
3. 비밀번호 모달 표시

---

### Phase 10: 비밀번호 설정 및 화면 전환

#### 10.1 비밀번호 설정
**파일**: `AuthForm.tsx:120-173`

**처리**:
1. 비밀번호 설정 API 호출
2. localStorage 정리 (선택적)

**화면 전환**:
- 추이보기: `/results-trend?uuid=...&hospital=...&sessionId=...`
- 질병예측리포트: `/disease-report?uuid=...&hospital=...`

---

## 3. 데이터 저장 위치 및 시점

### 3.1 Redis 세션 (임시, 30분 TTL)

**저장 시점**:
1. 세션 생성 시: `user_info`, `redirect_path`, `terms_agreed`
2. 인증 완료 시: `temp_auth_data` → `auth_data`
3. 데이터 수집 중: `health_data`, `prescription_data`
4. 환자 식별 후: `patient_uuid`, `hospital_id`
5. 완료 시: `collection_completed`, `collection_end_time`

**키 구조**: `tilko_session:{session_id}`

---

### 3.2 PostgreSQL (영구 저장)

**저장 시점 및 테이블**:

1. **환자 식별 후** (UUID 생성/조회 직후):
   - `welno.welno_patients` - 환자 정보
   - `welno.tb_wello_terms_agreement` - 약관 동의

2. **데이터 수집 완료 후** (파일 → DB):
   - `welno.welno_checkup_data` - 건강검진 데이터
   - `welno.welno_prescription_data` - 처방전 데이터

3. **Mediarc 완료 후** (질병예측리포트 케이스):
   - `welno.welno_mediarc_reports` - 리포트 데이터
   - `welno.tb_campaign_payments` - 캠페인 상태 업데이트

---

### 3.3 파일 시스템 (백업)

**저장 위치**: `/home/workspace/PROJECT_WELLO_BEFE/tilko_data/`

**폴더 구조**:
- `pending/` - DB 저장 대기 중
- `completed/` - DB 저장 완료
- `failed/` - DB 저장 실패

**저장 시점**: 데이터 수집 직후 (DB 저장 전)

---

### 3.4 프론트엔드 localStorage

**저장 시점 및 키**:

1. **세션 시작 후**:
   - `STORAGE_KEYS.TILKO_SESSION_ID` - 세션 ID

2. **인증 완료 후** (WebSocket `auth_completed`):
   - `STORAGE_KEYS.PATIENT_UUID` - 환자 UUID
   - `STORAGE_KEYS.HOSPITAL_ID` - 병원 ID

3. **약관 동의 시**:
   - `STORAGE_KEYS.TILKO_TERMS_AGREED` - 약관 동의 정보 (JSON)

4. **데이터 수집 중** (플래그):
   - `'tilko_manual_collect'` - 수동 수집 플래그 (하드코딩)
   - `'tilko_collecting_status'` - 수집 상태 (하드코딩)
   - `'tilko_auth_waiting'` - 인증 대기 (하드코딩)

---

### 3.5 프론트엔드 IndexedDB

**저장 시점**:

1. **WebSocket `auth_completed` 이벤트**:
   - `AuthForm.tsx:348-420`
   - 조건: `data.health_data || data.prescription_data` 존재
   - 모드: `'merge'`

2. **WebSocket `completed` 이벤트**:
   - `AuthForm.tsx:553-607` (onStatusUpdate)
   - 조건: `status === 'completed'`
   - 모드: `'merge'`

3. **폴링 완료 감지**:
   - `AuthForm.tsx:756-813`
   - 조건: `data.status === 'completed'`
   - 모드: `'merge'`

**저장 데이터**:
- `WelnoHealthDB.health_data` 스토어
- 키: `uuid` (primary key)

---

## 4. WebSocket 스트리밍 메시지 흐름

### 4.1 메시지 타입 및 순서

```
1. connection_established
   ↓
2. session_status (초기 상태)
   ↓
3. auth_key_received (cxId 포함)
   ↓
4. auth_waiting
   ↓
5. auth_completed (auth_data 포함)
   ↓
6. streaming_status: "fetching_health_data"
   ↓
7. streaming_status: "health_data_completed" ← ✅ UUID/Hospital 포함
   ↓
8. streaming_status: "mediarc_generating" (질병예측리포트만)
   ↓
9. streaming_status: "mediarc_completed_password_ready" (질병예측리포트만)
   ↓
10. streaming_status: "fetching_prescription_data"
   ↓
11. streaming_status: "prescription_completed" ← ✅ 새로 추가
   ↓
12. streaming_status: "completed" (전체 완료)
```

---

### 4.2 메시지 데이터 구조

#### health_data_completed
```json
{
  "type": "streaming_status",
  "status": "health_data_completed",
  "message": "건강검진 데이터 {count}건 수집했습니다.",
  "data": {
    "count": 5,
    "patient_uuid": "uuid",      // ✅ 새로 추가
    "hospital_id": "PEERNINE"    // ✅ 새로 추가
  }
}
```

#### mediarc_completed_password_ready
```json
{
  "type": "streaming_status",
  "status": "mediarc_completed_password_ready",
  "message": "리포트 생성 완료!",
  "data": {
    "patient_uuid": "uuid",
    "hospital_id": "PEERNINE"
  }
}
```

#### prescription_completed
```json
{
  "type": "streaming_status",
  "status": "prescription_completed",
  "message": "처방전 데이터 {count}건 수집했습니다.",
  "data": {
    "count": 9,
    "patient_uuid": "uuid",
    "hospital_id": "PEERNINE"
  }
}
```

---

## 5. 중간 저장 시점 요약

### 5.1 백엔드 저장 시점

| 시점 | 저장 위치 | 데이터 |
|------|-----------|--------|
| 세션 생성 | Redis | user_info, redirect_path, terms_agreed |
| 인증 완료 | Redis | auth_data (temp_auth_data → auth_data) |
| 건강검진 수집 | Redis | health_data |
| 환자 식별 | PostgreSQL | welno_patients, tb_wello_terms_agreement |
| 데이터 수집 완료 | 파일 시스템 | pending/{session_id}_*.json |
| 파일 → DB | PostgreSQL | welno_checkup_data, welno_prescription_data |
| 처방전 수집 | Redis | prescription_data |
| Mediarc 완료 | PostgreSQL | welno_mediarc_reports |

---

### 5.2 프론트엔드 저장 시점

| 시점 | 저장 위치 | 데이터 |
|------|-----------|--------|
| 세션 시작 | localStorage | TILKO_SESSION_ID |
| 인증 완료 | localStorage | PATIENT_UUID, HOSPITAL_ID |
| 인증 완료 | IndexedDB | healthData, prescriptionData (조건부) |
| 데이터 완료 | IndexedDB | healthData, prescriptionData (merge) |
| 약관 동의 | localStorage | TILKO_TERMS_AGREED |

---

## 6. 데이터 동기화 지점

### 6.1 프론트엔드 → 백엔드
- 세션 시작: 사용자 정보, 약관 정보, 진입 경로
- 데이터 수집 요청: 세션 ID만

### 6.2 백엔드 → 프론트엔드
- WebSocket: 실시간 상태 업데이트
- 폴링: WebSocket 실패 시 백업

### 6.3 중간 저장 동기화
- Redis 세션: WebSocket 메시지와 동기화
- PostgreSQL: 파일 저장 후 비동기 처리
- IndexedDB: WebSocket/폴링 완료 시점에 저장

---

## 7. 잠재적 문제점

### 7.1 데이터 불일치 가능성
1. **Redis vs PostgreSQL**: 파일 → DB 저장이 실패할 수 있음
2. **IndexedDB vs PostgreSQL**: 프론트엔드가 오래된 데이터를 가질 수 있음
3. **localStorage vs 세션**: 세션 만료 시 localStorage는 남아있음

### 7.2 타이밍 이슈
1. **UUID 생성 전 WebSocket 알림**: `health_data_completed` 시점에 UUID가 없을 수 있음
   - 해결: WebSocket 데이터에 UUID 포함 (✅ 완료)

2. **Mediarc 생성 중 처방전 완료**: 병렬 처리로 순서 보장 안됨
   - 현재: 각각 독립적으로 처리됨

3. **IndexedDB 저장 시점**: 여러 곳에서 저장 시도 (중복 가능)
   - 현재: `merge` 모드로 중복 방지

---

## 8. 개선 제안

### 8.1 데이터 일관성
1. IndexedDB 저장 시점 통일 (완료 시점에만)
2. localStorage 키 상수화 (하드코딩 제거)
3. 세션 키 타입 정의 (백엔드)

### 8.2 에러 처리
1. 파일 저장 실패 시 재시도 로직
2. DB 저장 실패 시 파일 보관 및 재시도
3. WebSocket 연결 끊김 시 폴링으로 복구

---

## 9. 검증 체크리스트

### 백엔드
- [ ] 세션에 redirect_path, terms_agreed 저장 확인
- [ ] UUID 생성 후 약관 DB 저장 확인
- [ ] health_data_completed에 UUID/Hospital 포함 확인
- [ ] prescription_completed 이벤트 전송 확인
- [ ] Mediarc 헬퍼 함수 정상 동작 확인

### 프론트엔드
- [ ] 세션 시작 시 redirect_path, terms_agreed 전달 확인
- [ ] health_data_completed 분기 처리 확인
- [ ] Mediarc 이벤트 핸들러 동작 확인
- [ ] 토스트 알림 표시 확인
- [ ] IndexedDB 저장 시점 확인

### 통합
- [ ] 진입 경로별 플로우 정상 동작
- [ ] WebSocket 메시지 순서 확인
- [ ] 데이터 저장 일관성 확인
